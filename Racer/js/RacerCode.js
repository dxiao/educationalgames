// Generated by CoffeeScript 1.6.3
(function() {
  var CommandType, ExecutionError, ExecutionOrder, GetShared, Increment, Lock, Memory, MemoryState, Module, ParseCommand, Process, PuzzleSet, SetShared, Unlock, Variable, copy, extend,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  Module = {};

  window.RacerCode = Module;

  extend = function(obj, mixin) {
    var method, name;
    for (name in mixin) {
      method = mixin[name];
      obj[name] = method;
    }
    return obj;
  };

  copy = function(obj) {
    return extend({}, obj);
  };

  Module.MemoryState = MemoryState = (function() {
    function MemoryState(values) {
      if (values == null) {
        values = {};
      }
      this.values = copy(values);
    }

    MemoryState.prototype.get = function(name) {
      return this.values[name];
    };

    MemoryState.prototype.set = function(name, value) {
      var newValues;
      newValues = copy(this.values);
      newValues[name] = value;
      return new MemoryState(newValues);
    };

    return MemoryState;

  })();

  Module.Memory = Memory = (function() {
    function Memory(startValues) {
      this.startValues = startValues != null ? startValues : {};
      this.reset(startValues);
    }

    Memory.prototype.set = function(name, value) {
      return this.state = this.state.set(name, value);
    };

    Memory.prototype.get = function(name) {
      return this.state.get(name);
    };

    Memory.prototype.reset = function(values) {
      if (values == null) {
        values = this.startValues;
      }
      return this.state = new MemoryState(values);
    };

    return Memory;

  })();

  Module.Process = Process = (function() {
    function Process(name, commands, memory) {
      this.name = name;
      this.commands = commands;
      this.memory = memory;
      this.reset();
    }

    Process.prototype.reset = function() {
      this.commandLine = 0;
      return this.memory.reset();
    };

    Process.prototype.step = function() {
      if (this.commandLine >= this.commands.length) {
        throw new Error("Process " + this.name + " has no more instructions!");
      }
      this.commands[this.commandLine].execute();
      return this.commandLine++;
    };

    Process.prototype.getState = function() {
      return this.memory.state.values;
    };

    return Process;

  })();

  Module.Variable = Variable = (function() {
    function Variable(name, memory) {
      this.name = name;
      this.memory = memory;
    }

    Variable.prototype.get = function() {
      return this.memory.get(this.name);
    };

    Variable.prototype.set = function(value) {
      return this.memory.set(this.name, value);
    };

    return Variable;

  })();

  Module.CommandType = CommandType = (function() {
    function CommandType(label) {
      this.label = label;
    }

    CommandType.prototype.execute = function() {
      throw new ReferenceError("Execute function not implemented!");
    };

    return CommandType;

  })();

  Module.ExecutionError = ExecutionError = (function(_super) {
    __extends(ExecutionError, _super);

    function ExecutionError(message) {
      this.message = message;
    }

    return ExecutionError;

  })(Error);

  Module.GetShared = GetShared = (function(_super) {
    __extends(GetShared, _super);

    function GetShared(localVar, sharedVar) {
      this.localVar = localVar;
      this.sharedVar = sharedVar;
      GetShared.__super__.constructor.call(this, "Get " + this.localVar.name + " from shared." + this.sharedVar.name);
    }

    GetShared.prototype.execute = function() {
      return this.localVar.set(this.sharedVar.get());
    };

    return GetShared;

  })(CommandType);

  Module.SetShared = SetShared = (function(_super) {
    __extends(SetShared, _super);

    function SetShared(localVar, sharedVar) {
      this.localVar = localVar;
      this.sharedVar = sharedVar;
      SetShared.__super__.constructor.call(this, "Set shared." + this.sharedVar.name + " with " + this.localVar.name);
    }

    SetShared.prototype.execute = function() {
      return this.sharedVar.set(this.localVar.get());
    };

    return SetShared;

  })(CommandType);

  Module.Lock = Lock = (function(_super) {
    __extends(Lock, _super);

    function Lock(sharedLockVar, processName) {
      this.sharedLockVar = sharedLockVar;
      this.processName = processName;
      Lock.__super__.constructor.call(this, "Acquire lock " + this.sharedLockVar.name);
    }

    Lock.prototype.execute = function() {
      var lockOwner;
      lockOwner = this.sharedLockVar.get();
      if (lockOwner === false) {
        return this.sharedLockVar.set(this.processName);
      } else {
        throw new ExecutionError("Can not get lock " + this.sharedLockVar.name + "; currently held by process " + lockOwner);
      }
    };

    return Lock;

  })(CommandType);

  Module.Unlock = Unlock = (function(_super) {
    __extends(Unlock, _super);

    function Unlock(sharedLockVar, processName) {
      this.sharedLockVar = sharedLockVar;
      this.processName = processName;
      Unlock.__super__.constructor.call(this, "Release lock " + this.sharedLockVar.name);
    }

    Unlock.prototype.execute = function() {
      var lockOwner;
      lockOwner = this.sharedLockVar.get();
      if (lockOwner === this.processname) {
        return this.sharedLockVar.set(false);
      } else if (lockOwner === false) {
        throw new ExecutionError("Can not release lock not held by any process!");
      } else {
        throw new ExecutionError("Can not release lock not held by process " + lockOwner);
      }
    };

    return Unlock;

  })(CommandType);

  Module.Increment = Increment = (function(_super) {
    __extends(Increment, _super);

    function Increment(variable, increment) {
      this.variable = variable;
      this.increment = increment;
      Increment.__super__.constructor.call(this, "Increment " + this.variable.name + " by " + this.increment);
    }

    Increment.prototype.execute = function() {
      return this.variable.set(this.variable.get() + this.increment);
    };

    return Increment;

  })(CommandType);

  ParseCommand = function(command, process, memories) {
    switch (command.type) {
      case "Get":
        return new GetShared(new Variable(command.local, memories[process]), new Variable(command.shared, memories.shared));
      case "Set":
        return new SetShared(new Variable(command.local, memories[process]), new Variable(command.shared, memories.shared));
      case "Increment":
        return new Increment(new Variable(command.variable, memories[process]), command.increment);
      case "Lock":
        return new Lock(new Variable(command.lock, memories.shared), process);
      case "Unlock":
        return new Unlock(new Variable(command.loc, memories.shared), process);
      default:
        throw new TypeError("Did not recognize command of type " + command.type);
    }
  };

  Module.PuzzleSet = PuzzleSet = (function() {
    function PuzzleSet(set) {
      var command, commands, memory, name, process, _ref;
      this.name = set.name;
      this.shared = new Memory(set.shared);
      this.memories = {
        shared: this.shared
      };
      this.processes = {};
      _ref = set.processes;
      for (name in _ref) {
        process = _ref[name];
        this.memories[name] = memory = new Memory(process.memory);
        commands = (function() {
          var _i, _len, _ref1, _results;
          _ref1 = process.commands;
          _results = [];
          for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
            command = _ref1[_i];
            _results.push(ParseCommand(command, name, this.memories));
          }
          return _results;
        }).call(this);
        this.processes[name] = new Process(name, commands, memory);
      }
      this.finish = set.finish;
    }

    PuzzleSet.prototype.reset = function() {
      var name, process, _ref, _results;
      this.shared.reset();
      _ref = this.processes;
      _results = [];
      for (name in _ref) {
        process = _ref[name];
        _results.push(process.reset());
      }
      return _results;
    };

    PuzzleSet.prototype.stepProcess = function(processName) {
      return this.processes[processName].step;
    };

    PuzzleSet.prototype.checkFinish = function() {
      var errors, finals, memory, name, value, values, _ref;
      errors = [];
      _ref = this.finish;
      for (memory in _ref) {
        finals = _ref[memory];
        values = this.memories[memory].state.values;
        for (name in finals) {
          value = finals[name];
          if (values[name] !== value) {
            errors.push({
              memory: memory,
              expected: value,
              actual: values[name]
            });
          }
        }
      }
      return errors;
    };

    return PuzzleSet;

  })();

  Module.ExecutionOrder = ExecutionOrder = (function() {
    function ExecutionOrder(puzzleOrOrdering) {
      var i, name, process, _i, _ref, _ref1;
      if (puzzleOrOrdering instanceof PuzzleSet) {
        this.ordering = [];
        _ref = puzzleOrOrdering.processes;
        for (name in _ref) {
          process = _ref[name];
          for (i = _i = 1, _ref1 = process.commands.length; 1 <= _ref1 ? _i <= _ref1 : _i >= _ref1; i = 1 <= _ref1 ? ++_i : --_i) {
            this.ordering.push(name);
          }
        }
      } else {
        this.ordering = puzzleOrOrdering;
      }
    }

    ExecutionOrder.prototype.getIndexFromCommandOrder = function(pos) {
      var i, index, order, process, _i, _ref;
      index = 0;
      process = pos.process;
      order = pos.order;
      for (i = _i = _ref = this.ordering.length - 1; _i >= 0; i = _i += -1) {
        if (this.ordering[i] === process) {
          order--;
          if (order === -1) {
            console.log("index " + i);
            return i;
          }
        }
      }
      throw new Error("Could not find index for " + process + " order " + order);
    };

    ExecutionOrder.prototype.tryCommandMove = function(oldPos, newPos) {
      var incr, length, newIndex, oldIndex, process, testIndex;
      process = oldPos.process;
      oldIndex = this.getIndexFromCommandOrder(oldPos);
      newIndex = this.getIndexFromCommandOrder(newPos);
      if (oldIndex === newIndex) {
        return true;
      }
      incr = oldIndex > newIndex ? -1 : 1;
      length = this.ordering.length;
      testIndex = oldIndex;
      while (this.ordering[testIndex] === process) {
        testIndex += incr;
        if (testIndex < 0 || testIndex >= length) {
          return false;
        }
      }
      if (testIndex < 0 || testIndex >= length) {
        return false;
      }
      console.log("swapping " + oldIndex + "," + testIndex);
      this.ordering[oldIndex] = this.ordering[testIndex];
      this.ordering[testIndex] = process;
      return true;
    };

    return ExecutionOrder;

  })();

}).call(this);

/*
//@ sourceMappingURL=RacerCode.map
*/
