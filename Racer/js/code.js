// Generated by CoffeeScript 1.6.3
(function() {
  var CommandType, ExecutionOrder, GetShared, Increment, Lock, Memory, MemoryState, Module, ParseCommand, Process, PuzzleSet, SetShared, Unlock, Variable, copy, createElement, extend, getProcessToCssNumMapping, initPuzzle,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  less.watch();

  Module = {};

  window.RaceCode = Module;

  extend = function(obj, mixin) {
    var method, name;
    obj[name] = (function() {
      var _results;
      _results = [];
      for (name in mixin) {
        method = mixin[name];
        _results.push(method);
      }
      return _results;
    })();
    return obj;
  };

  copy = function(obj) {
    return extend({}, obj);
  };

  createElement = function(tag) {
    return $(document.createElement(tag));
  };

  Module.MemoryState = MemoryState = (function() {
    function MemoryState(values) {
      if (values == null) {
        values = {};
      }
      this.values = copy(values);
    }

    MemoryState.prototype.get = function(name) {
      return this.values[name];
    };

    MemoryState.prototype.set = function(name, value) {
      var newValues;
      newValues = copy(this.values);
      newValues[name] = value;
      return new MemoryState(newValues);
    };

    return MemoryState;

  })();

  Module.Memory = Memory = (function() {
    function Memory(startValues) {
      this.startValues = startValues != null ? startValues : {};
      this.reset(startValues);
    }

    Memory.prototype.set = function(name, value) {
      return this.state = this.state.set(name, value);
    };

    Memory.prototype.get = function(name) {
      return this.state.get(name);
    };

    Memory.prototype.reset = function(values) {
      if (values == null) {
        values = this.startValues;
      }
      return this.state = new MemoryState(values);
    };

    return Memory;

  })();

  Module.Process = Process = (function() {
    function Process(name, commands, memory) {
      this.name = name;
      this.commands = commands;
      this.memory = memory;
      this.reset();
    }

    Process.prototype.reset = function() {
      this.commandLine = 0;
      return this.memory.reset;
    };

    Process.prototype.step = function() {
      if (this.commandLine >= this.commands.length) {
        throw new Error("Process " + this.name + " has no more instructions!");
      }
      this.commands[this.commandLine].execute();
      return this.commandLine++;
    };

    Process.prototype.getState = function() {
      return this.memory.state.values;
    };

    return Process;

  })();

  Module.Variable = Variable = (function() {
    function Variable(name, memory) {
      this.name = name;
      this.memory = memory;
    }

    Variable.prototype.get = function() {
      return this.memory.get(this.name);
    };

    Variable.prototype.set = function(value) {
      return this.memory.set(this.name, value);
    };

    return Variable;

  })();

  Module.CommandType = CommandType = (function() {
    function CommandType(label) {
      this.label = label;
    }

    CommandType.prototype.execute = function() {
      throw new ReferenceError("Execute function not implemented!");
    };

    return CommandType;

  })();

  Module.GetShared = GetShared = (function(_super) {
    __extends(GetShared, _super);

    function GetShared(localVar, sharedVar) {
      this.localVar = localVar;
      this.sharedVar = sharedVar;
      GetShared.__super__.constructor.call(this, "Get " + this.localVar.name + " from shared memory " + this.sharedVar.name);
    }

    GetShared.prototype.execute = function() {
      return this.localVar.set(this.sharedVar.get());
    };

    return GetShared;

  })(CommandType);

  Module.SetShared = SetShared = (function(_super) {
    __extends(SetShared, _super);

    function SetShared(localVar, sharedVar) {
      this.localVar = localVar;
      this.sharedVar = sharedVar;
      SetShared.__super__.constructor.call(this, "Set shared memory " + this.sharedVar.name + " with " + this.localVar.name);
    }

    SetShared.prototype.execute = function() {
      return this.sharedVar.set(this.localVar.get());
    };

    return SetShared;

  })(CommandType);

  Module.Lock = Lock = (function(_super) {
    __extends(Lock, _super);

    function Lock(sharedLockVar, processName) {
      this.sharedLockVar = sharedLockVar;
      this.processName = processName;
      Lock.__super__.constructor.call(this, "Acquire lock " + this.sharedLockVar.name);
    }

    Lock.prototype.execute = function() {
      var lockOwner;
      lockOwner = this.sharedLockVar.get();
      if (lockOwner === false) {
        return this.sharedLockVar.set(this.processName);
      } else {
        throw new Error("Can not get lock " + this.sharedLockVar.name + "; currently held by process " + lockOwner);
      }
    };

    return Lock;

  })(CommandType);

  Module.Unlock = Unlock = (function(_super) {
    __extends(Unlock, _super);

    function Unlock(sharedLockVar, processName) {
      this.sharedLockVar = sharedLockVar;
      this.processName = processName;
      Unlock.__super__.constructor.call(this, "Release lock " + this.sharedLockVar.name);
    }

    Unlock.prototype.execute = function() {
      var lockOwner;
      lockOwner = this.sharedLockVar.get();
      if (lockOwner === this.processname) {
        return this.sharedLockVar.set(false);
      } else if (lockOwner === false) {
        throw new Error("Can not release lock not held by any process!");
      } else {
        throw new Error("Can not release lock not held by process " + lockOwner);
      }
    };

    return Unlock;

  })(CommandType);

  Module.Increment = Increment = (function(_super) {
    __extends(Increment, _super);

    function Increment(variable, increment) {
      this.variable = variable;
      this.increment = increment;
      Increment.__super__.constructor.call(this, "Increment " + this.variable + " by " + this.increment);
    }

    Increment.prototype.execute = function() {
      return this.variable.set(this.variable.get + this.increment);
    };

    return Increment;

  })(CommandType);

  ParseCommand = function(command, process, memories) {
    switch (command.type) {
      case "Get":
        return new GetShared(new Variable(command.local, memories[process]), new Variable(command.shared, memories.shared));
      case "Set":
        return new SetShared(new Variable(command.local, memories[process]), new Variable(command.shared, memories.shared));
      case "Increment":
        return new Increment(new Variable(command.variable, memories[process]), command.increment);
      case "Lock":
        return new Lock(new Variable(command.lock, memories.shared), process);
      case "Unlock":
        return new Unlock(new Variable(command.loc, memories.shared), process);
      default:
        throw new TypeError("Did not recognize command of type " + command.type);
    }
  };

  Module.PuzzleSet = PuzzleSet = (function() {
    function PuzzleSet(set) {
      var command, commands, memory, name, process, _ref;
      this.shared = new Memory(set.shared);
      this.memories = {
        shared: this.shared
      };
      this.processes = {};
      _ref = set.processes;
      for (name in _ref) {
        process = _ref[name];
        this.memories[name] = memory = new Memory(process.memory);
        commands = (function() {
          var _i, _len, _ref1, _results;
          _ref1 = process.commands;
          _results = [];
          for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
            command = _ref1[_i];
            _results.push(ParseCommand(command, name, this.memories));
          }
          return _results;
        }).call(this);
        this.processes[name] = new Process(name, commands, memory);
      }
      this.finish = set.finish;
    }

    PuzzleSet.prototype.reset = function() {
      var name, process, _ref, _results;
      this.shared.reset();
      _ref = this.processes;
      _results = [];
      for (name in _ref) {
        process = _ref[name];
        _results.push(process.reset());
      }
      return _results;
    };

    PuzzleSet.prototype.stepProcess = function(processName) {
      return this.processes[processName].step;
    };

    PuzzleSet.prototype.checkFinish = function() {
      var errors, finals, memory, name, value, values, _ref;
      errors = [];
      _ref = this.finish;
      for (memory in _ref) {
        finals = _ref[memory];
        values = this.memories[memory];
        for (name in finals) {
          value = finals[name];
          if (values[name] !== value) {
            errors.push({
              memory: memory,
              expected: value,
              actual: values[name]
            });
          }
        }
      }
      return errors;
    };

    return PuzzleSet;

  })();

  Module.ExecutionOrder = ExecutionOrder = (function() {
    function ExecutionOrder(puzzleOrOrdering) {
      var i, name, process, _i, _ref, _ref1;
      if (puzzleOrOrdering instanceof PuzzleSet) {
        this.ordering = [];
        _ref = puzzleOrOrdering.processes;
        for (name in _ref) {
          process = _ref[name];
          for (i = _i = 1, _ref1 = process.commands.length; 1 <= _ref1 ? _i <= _ref1 : _i >= _ref1; i = 1 <= _ref1 ? ++_i : --_i) {
            this.ordering.push(name);
          }
        }
      } else {
        this.ordering = puzzleOrOrdering;
      }
    }

    return ExecutionOrder;

  })();

  Module.simpleRace = {
    name: "Simple Race",
    description: "A simple race condition to make sure this works",
    shared: {
      balance: 100
    },
    processes: {
      A: {
        memory: {},
        commands: [
          {
            type: "Get",
            local: "a",
            shared: "balance"
          }, {
            type: "Increment",
            variable: "a",
            increment: 3
          }, {
            type: "Set",
            local: "a",
            shared: "balance"
          }
        ]
      },
      B: {
        memory: {},
        commands: [
          {
            type: "Get",
            local: "b",
            shared: "balance"
          }, {
            type: "Increment",
            variable: "b",
            increment: -7
          }, {
            type: "Set",
            local: "b",
            shared: "balance"
          }
        ]
      }
    },
    finish: {
      shared: {
        balance: 100
      }
    }
  };

  getProcessToCssNumMapping = function(processes) {
    var count, cssMapping, name, process;
    cssMapping = {};
    count = 0;
    for (name in processes) {
      process = processes[name];
      cssMapping[name] = count;
      count++;
    }
    return cssMapping;
  };

  Module.initPuzzle = initPuzzle = function(root) {
    var alignedProcessLabels, cssMapping, cssNum, ordering, processName, processStateLabels, puzzleSet, puzzleSpec, table, tbody, thead;
    puzzleSpec = Module[root.attr("data-puzzleset")];
    if (puzzleSpec == null) {
      throw new Error("Could not find puzzle " + (root.attr("data-puzzleset")));
    }
    puzzleSet = new PuzzleSet(puzzleSpec);
    ordering = new ExecutionOrder(puzzleSet);
    cssMapping = getProcessToCssNumMapping(puzzleSet.processes);
    root.data("puzzleSet", puzzleSet).data("ordering", ordering).data("cssMapping", cssMapping);
    alignedProcessLabels = [];
    processStateLabels = [];
    for (processName in cssMapping) {
      cssNum = cssMapping[processName];
      alignedProcessLabels[cssNum] = createElement("div").addClass("process" + cssNum).text(processName);
      processStateLabels[cssNum] = createElement("th").addClass("process" + cssNum).text(processName + " Memory State");
    }
    thead = createElement("thead").append(createElement("tr").append(createElement("th").addClass("alignedCode").append(alignedProcessLabels)).append(processStateLabels).append(createElement("th").text("Shared Memory State")));
    tbody = createElement("tbody");
    return table = createElement("table").addClass("puzzleTable").append(thead).append(tbody).appendTo(root);
  };

  $(function() {
    return $("[data-role='racerpuzzle']").each(function() {
      return initPuzzle($(this));
    });
  });

}).call(this);

/*
//@ sourceMappingURL=code.map
*/
