// Generated by CoffeeScript 1.6.3
(function() {
  var CommandType, ExecutionError, ExecutionOrder, GetShared, Increment, Lock, Memory, MemoryState, Module, ParseCommand, Process, PuzzleSet, SetShared, Unlock, Variable, copy, createElement, createPuzzleOutput, createPuzzleTable, executePuzzle, extend, fillInCommandsColumn, getProcessToCssNumMapping, initPuzzle, printMemoryState,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  less.watch();

  Module = {};

  window.RaceCode = Module;

  extend = function(obj, mixin) {
    var method, name;
    for (name in mixin) {
      method = mixin[name];
      obj[name] = method;
    }
    return obj;
  };

  copy = function(obj) {
    return extend({}, obj);
  };

  createElement = function(tag) {
    return $(document.createElement(tag));
  };

  Module.MemoryState = MemoryState = (function() {
    function MemoryState(values) {
      if (values == null) {
        values = {};
      }
      this.values = copy(values);
    }

    MemoryState.prototype.get = function(name) {
      return this.values[name];
    };

    MemoryState.prototype.set = function(name, value) {
      var newValues;
      newValues = copy(this.values);
      newValues[name] = value;
      return new MemoryState(newValues);
    };

    return MemoryState;

  })();

  Module.Memory = Memory = (function() {
    function Memory(startValues) {
      this.startValues = startValues != null ? startValues : {};
      this.reset(startValues);
    }

    Memory.prototype.set = function(name, value) {
      return this.state = this.state.set(name, value);
    };

    Memory.prototype.get = function(name) {
      return this.state.get(name);
    };

    Memory.prototype.reset = function(values) {
      if (values == null) {
        values = this.startValues;
      }
      return this.state = new MemoryState(values);
    };

    return Memory;

  })();

  Module.Process = Process = (function() {
    function Process(name, commands, memory) {
      this.name = name;
      this.commands = commands;
      this.memory = memory;
      this.reset();
    }

    Process.prototype.reset = function() {
      this.commandLine = 0;
      return this.memory.reset;
    };

    Process.prototype.step = function() {
      if (this.commandLine >= this.commands.length) {
        throw new Error("Process " + this.name + " has no more instructions!");
      }
      this.commands[this.commandLine].execute();
      return this.commandLine++;
    };

    Process.prototype.getState = function() {
      return this.memory.state.values;
    };

    return Process;

  })();

  Module.Variable = Variable = (function() {
    function Variable(name, memory) {
      this.name = name;
      this.memory = memory;
    }

    Variable.prototype.get = function() {
      return this.memory.get(this.name);
    };

    Variable.prototype.set = function(value) {
      return this.memory.set(this.name, value);
    };

    return Variable;

  })();

  Module.CommandType = CommandType = (function() {
    function CommandType(label) {
      this.label = label;
    }

    CommandType.prototype.execute = function() {
      throw new ReferenceError("Execute function not implemented!");
    };

    return CommandType;

  })();

  Module.ExecutionError = ExecutionError = (function(_super) {
    __extends(ExecutionError, _super);

    function ExecutionError(message) {
      this.message = message;
    }

    return ExecutionError;

  })(Error);

  Module.GetShared = GetShared = (function(_super) {
    __extends(GetShared, _super);

    function GetShared(localVar, sharedVar) {
      this.localVar = localVar;
      this.sharedVar = sharedVar;
      GetShared.__super__.constructor.call(this, "Get " + this.localVar.name + " from shared." + this.sharedVar.name);
    }

    GetShared.prototype.execute = function() {
      return this.localVar.set(this.sharedVar.get());
    };

    return GetShared;

  })(CommandType);

  Module.SetShared = SetShared = (function(_super) {
    __extends(SetShared, _super);

    function SetShared(localVar, sharedVar) {
      this.localVar = localVar;
      this.sharedVar = sharedVar;
      SetShared.__super__.constructor.call(this, "Set shared." + this.sharedVar.name + " with " + this.localVar.name);
    }

    SetShared.prototype.execute = function() {
      return this.sharedVar.set(this.localVar.get());
    };

    return SetShared;

  })(CommandType);

  Module.Lock = Lock = (function(_super) {
    __extends(Lock, _super);

    function Lock(sharedLockVar, processName) {
      this.sharedLockVar = sharedLockVar;
      this.processName = processName;
      Lock.__super__.constructor.call(this, "Acquire lock " + this.sharedLockVar.name);
    }

    Lock.prototype.execute = function() {
      var lockOwner;
      lockOwner = this.sharedLockVar.get();
      if (lockOwner === false) {
        return this.sharedLockVar.set(this.processName);
      } else {
        throw new ExecutionError("Can not get lock " + this.sharedLockVar.name + "; currently held by process " + lockOwner);
      }
    };

    return Lock;

  })(CommandType);

  Module.Unlock = Unlock = (function(_super) {
    __extends(Unlock, _super);

    function Unlock(sharedLockVar, processName) {
      this.sharedLockVar = sharedLockVar;
      this.processName = processName;
      Unlock.__super__.constructor.call(this, "Release lock " + this.sharedLockVar.name);
    }

    Unlock.prototype.execute = function() {
      var lockOwner;
      lockOwner = this.sharedLockVar.get();
      if (lockOwner === this.processname) {
        return this.sharedLockVar.set(false);
      } else if (lockOwner === false) {
        throw new ExecutionError("Can not release lock not held by any process!");
      } else {
        throw new ExecutionError("Can not release lock not held by process " + lockOwner);
      }
    };

    return Unlock;

  })(CommandType);

  Module.Increment = Increment = (function(_super) {
    __extends(Increment, _super);

    function Increment(variable, increment) {
      this.variable = variable;
      this.increment = increment;
      Increment.__super__.constructor.call(this, "Increment " + this.variable.name + " by " + this.increment);
    }

    Increment.prototype.execute = function() {
      return this.variable.set(this.variable.get() + this.increment);
    };

    return Increment;

  })(CommandType);

  ParseCommand = function(command, process, memories) {
    switch (command.type) {
      case "Get":
        return new GetShared(new Variable(command.local, memories[process]), new Variable(command.shared, memories.shared));
      case "Set":
        return new SetShared(new Variable(command.local, memories[process]), new Variable(command.shared, memories.shared));
      case "Increment":
        return new Increment(new Variable(command.variable, memories[process]), command.increment);
      case "Lock":
        return new Lock(new Variable(command.lock, memories.shared), process);
      case "Unlock":
        return new Unlock(new Variable(command.loc, memories.shared), process);
      default:
        throw new TypeError("Did not recognize command of type " + command.type);
    }
  };

  Module.PuzzleSet = PuzzleSet = (function() {
    function PuzzleSet(set) {
      var command, commands, memory, name, process, _ref;
      this.shared = new Memory(set.shared);
      this.memories = {
        shared: this.shared
      };
      this.processes = {};
      _ref = set.processes;
      for (name in _ref) {
        process = _ref[name];
        this.memories[name] = memory = new Memory(process.memory);
        commands = (function() {
          var _i, _len, _ref1, _results;
          _ref1 = process.commands;
          _results = [];
          for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
            command = _ref1[_i];
            _results.push(ParseCommand(command, name, this.memories));
          }
          return _results;
        }).call(this);
        this.processes[name] = new Process(name, commands, memory);
      }
      this.finish = set.finish;
    }

    PuzzleSet.prototype.reset = function() {
      var name, process, _ref, _results;
      this.shared.reset();
      _ref = this.processes;
      _results = [];
      for (name in _ref) {
        process = _ref[name];
        _results.push(process.reset());
      }
      return _results;
    };

    PuzzleSet.prototype.stepProcess = function(processName) {
      return this.processes[processName].step;
    };

    PuzzleSet.prototype.checkFinish = function() {
      var errors, finals, memory, name, value, values, _ref;
      errors = [];
      _ref = this.finish;
      for (memory in _ref) {
        finals = _ref[memory];
        values = this.memories[memory].state.values;
        for (name in finals) {
          value = finals[name];
          if (values[name] !== value) {
            errors.push({
              memory: memory,
              expected: value,
              actual: values[name]
            });
          }
        }
      }
      return errors;
    };

    return PuzzleSet;

  })();

  Module.ExecutionOrder = ExecutionOrder = (function() {
    function ExecutionOrder(puzzleOrOrdering) {
      var i, name, process, _i, _ref, _ref1;
      if (puzzleOrOrdering instanceof PuzzleSet) {
        this.ordering = [];
        _ref = puzzleOrOrdering.processes;
        for (name in _ref) {
          process = _ref[name];
          for (i = _i = 1, _ref1 = process.commands.length; 1 <= _ref1 ? _i <= _ref1 : _i >= _ref1; i = 1 <= _ref1 ? ++_i : --_i) {
            this.ordering.push(name);
          }
        }
      } else {
        this.ordering = puzzleOrOrdering;
      }
    }

    return ExecutionOrder;

  })();

  Module.simpleRace = {
    name: "Simple Race",
    description: "A simple race condition to make sure this works",
    shared: {
      balance: 100
    },
    processes: {
      A: {
        memory: {},
        commands: [
          {
            type: "Get",
            local: "atemp",
            shared: "balance"
          }, {
            type: "Increment",
            variable: "atemp",
            increment: 3
          }, {
            type: "Set",
            local: "atemp",
            shared: "balance"
          }
        ]
      },
      B: {
        memory: {},
        commands: [
          {
            type: "Get",
            local: "btemp",
            shared: "balance"
          }, {
            type: "Increment",
            variable: "btemp",
            increment: -7
          }, {
            type: "Set",
            local: "btemp",
            shared: "balance"
          }
        ]
      }
    },
    finish: {
      shared: {
        balance: 96
      }
    }
  };

  getProcessToCssNumMapping = function(processes) {
    var count, cssMapping, name, process;
    cssMapping = {};
    count = 0;
    for (name in processes) {
      process = processes[name];
      cssMapping[name] = count;
      count++;
    }
    return cssMapping;
  };

  Module.initPuzzle = initPuzzle = function(root) {
    var cssMapping, ordering, puzzleSet, puzzleSpec;
    puzzleSpec = Module[root.attr("data-puzzleset")];
    if (puzzleSpec == null) {
      throw new Error("Could not find puzzle " + (root.attr("data-puzzleset")));
    }
    puzzleSet = new PuzzleSet(puzzleSpec);
    ordering = new ExecutionOrder(puzzleSet);
    cssMapping = getProcessToCssNumMapping(puzzleSet.processes);
    root.data("puzzleSet", puzzleSet).data("ordering", ordering).data("cssMapping", cssMapping);
    createPuzzleTable(root, puzzleSet, ordering.ordering, cssMapping);
    createPuzzleOutput(root, puzzleSet.finish, cssMapping);
    fillInCommandsColumn(root, puzzleSet.processes, ordering.ordering, cssMapping);
    return root.append(createElement("div").attr("data-role", "executionResult")).append(createElement("button").attr("type", "button").addClass("btn").addClass("btn-primary").text("Execute!").click((function() {
      return function() {
        return executePuzzle(root, puzzleSet, ordering, cssMapping);
      };
    })()));
  };

  printMemoryState = function(element, name, num, values) {
    var field, value, _results;
    if (name !== "shared") {
      element.addClass("process" + num);
    }
    _results = [];
    for (field in values) {
      value = values[field];
      _results.push(element.append(createElement("div").text(field + ": " + value)));
    }
    return _results;
  };

  Module.executePuzzle = executePuzzle = function(root, puzzleSet, ordering, cssMapping) {
    var cells, cssNum, diff, error, processName, processes, row, rows, _i, _len;
    puzzleSet.reset();
    processes = puzzleSet.processes;
    rows = root.find("tbody tr");
    for (_i = 0, _len = rows.length; _i < _len; _i++) {
      row = rows[_i];
      cells = $(row).children();
      processName = cells.first().children().first().data("processName");
      try {
        processes[processName].step();
      } catch (_error) {
        error = _error;
        if (error instanceof ExecutionError) {
          cells.eq(1 + cssMapping[processName]).text("HALT: " + error.message);
          break;
        } else {
          throw error;
        }
      }
      for (processName in cssMapping) {
        cssNum = cssMapping[processName];
        printMemoryState(cells.eq(1 + cssNum), processName, cssNum, processes[processName].getState());
      }
      printMemoryState(cells.eq(-1), "shared", -1, puzzleSet.memories["shared"].state.values);
    }
    diff = puzzleSet.checkFinish();
    if (diff.length > 0) {
      return root.find("[data-role='executionResult']").empty().append(createElement("div").addClass("alert").addClass("alert-success").text("Congratulations! You found an execution order which breaks the program!"));
    } else {
      return root.find("[data-role='executionResult']").empty().append(createElement("div").addClass("alert").addClass("alert-warning").text("This execution order comes out correct. Try ordering them differently!"));
    }
  };

  createPuzzleTable = function(root, puzzleSet, ordering, cssMapping) {
    var alignedProcessLabels, cssNum, processName, processStateLabels, rowTemplate, table, tbody, thead, _i, _len;
    alignedProcessLabels = [];
    processStateLabels = [];
    rowTemplate = createElement("tr").append(createElement("td").addClass("alignedCode"));
    for (processName in cssMapping) {
      cssNum = cssMapping[processName];
      alignedProcessLabels[cssNum] = createElement("div").addClass("process" + cssNum).text("Process " + processName);
      processStateLabels[cssNum] = createElement("th").addClass("process" + cssNum).text(processName + " Memory State");
      rowTemplate.append(createElement("td").addClass("process" + cssNum));
    }
    rowTemplate.append(createElement("td"));
    thead = createElement("thead").append(createElement("tr").append(createElement("th").addClass("alignedCode").append(alignedProcessLabels)).append(processStateLabels).append(createElement("th").text("Shared Memory State")));
    tbody = createElement("tbody");
    for (_i = 0, _len = ordering.length; _i < _len; _i++) {
      processName = ordering[_i];
      tbody.append(rowTemplate.clone());
    }
    return table = createElement("table").addClass("puzzleTable").append(thead).append(tbody).appendTo(root);
  };

  createPuzzleOutput = function(root, finish, cssMapping) {
    var area, box, data, name, _results;
    root.append(createElement("h4").text("Processes should complete with following memory state:"));
    box = createElement("div").addClass("code").appendTo(root);
    _results = [];
    for (name in finish) {
      data = finish[name];
      area = createElement("div").text(name + ":").appendTo(box);
      printMemoryState(area, name, cssMapping[name], data);
      _results.push(area.children().addClass("indentleft"));
    }
    return _results;
  };

  fillInCommandsColumn = function(root, processes, ordering, cssMapping) {
    var cell, command, commandCells, commands, process, processName, _i, _len, _results;
    commandCells = root.find("tbody td:first-child");
    commands = {};
    ordering = ordering.slice(0);
    for (processName in processes) {
      process = processes[processName];
      commands[processName] = process.commands.slice(0);
    }
    _results = [];
    for (_i = 0, _len = commandCells.length; _i < _len; _i++) {
      cell = commandCells[_i];
      processName = ordering.shift();
      command = commands[processName].shift();
      _results.push($(cell).empty().append(createElement("div").addClass("process" + cssMapping[processName]).text(command.label).data("processName", processName)));
    }
    return _results;
  };

  $(function() {
    return $("[data-role='racerpuzzle']").each(function() {
      return initPuzzle($(this));
    });
  });

}).call(this);

/*
//@ sourceMappingURL=code.map
*/
