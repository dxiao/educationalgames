// Generated by CoffeeScript 1.7.1
(function() {
  var Model, PlayerAuth, ProblemServer;

  Model = window.TeamerModel;

  PlayerAuth = (function() {
    PlayerAuth.$inject = ['$http', '$location'];

    function PlayerAuth($http, $location) {
      this.http = $http;
      this.location = $location;
    }

    PlayerAuth.prototype.submitLogin = function(name, callback) {
      return this.http({
        method: 'GET',
        url: '/teamerapi/login',
        params: {
          name: name
        }
      }).success((function(_this) {
        return function(data, status) {
          _this.player = new Model.Player(data, name);
          return callback(_this.player, null);
        };
      })(this)).error(function(data, status) {
        return callback(null, data);
      });
    };

    PlayerAuth.prototype.assertLoggedIn = function() {
      if (this.player == null) {
        console.log("AUTH: no player found, redirecting to login");
        this.location.path("/login");
        return false;
      } else {
        return this.player;
      }
    };

    return PlayerAuth;

  })();

  ProblemServer = (function() {
    ProblemServer.$inject = ['$http', '$location', 'playerAuth'];

    function ProblemServer($http, $location, playerAuth) {
      this.playerAuth = playerAuth;
      this.http = $http;
      this.location = $location;
    }

    ProblemServer.prototype.updateConfig = function() {
      var _ref;
      this.problem = this.location.path().split("/")[2];
      return this.id = (_ref = this.playerAuth.player) != null ? _ref.id : void 0;
    };

    ProblemServer.prototype.getFunctions = function() {
      this.updateConfig();
      return this.http({
        method: 'GET',
        url: '/teamerapi/game/' + this.problem + '/getFunctions',
        params: {
          id: this.id
        }
      });
    };

    ProblemServer.prototype.joinGame = function() {
      this.updateConfig();
      return this.http({
        method: 'GET',
        url: '/teamerapi/game/' + this.problem + '/joinGame',
        params: {
          id: this.id
        }
      });
    };

    return ProblemServer;

  })();

  angular.module('teamer', ['ngRoute']).config(function($routeProvider, $locationProvider) {
    return $routeProvider.when('/login', {
      templateUrl: 'teamer/views/login.html',
      controller: 'LoginController'
    }).when('/problem/:problem/:stage', {
      templateUrl: 'teamer/views/problem.html',
      controller: 'ProblemController'
    }).otherwise({
      templateUrl: 'teamer/views/null.html',
      controller: 'InitController'
    });
  }).controller('LoginController', [
    '$scope', '$location', 'playerAuth', function($scope, $location, playerAuth) {
      return $scope.submitName = function() {
        $scope.loginError = false;
        return $scope.id = playerAuth.submitLogin($scope.loginname, function(player, error) {
          if (player) {
            return $location.path("");
          } else {
            return $scope.loginError = error;
          }
        });
      };
    }
  ]).controller('InitController', [
    '$location', 'playerAuth', function($location, playerAuth) {
      if (playerAuth.assertLoggedIn()) {
        console.log("INIT: player detected, redirecting to problem");
        return $location.path("/problem/sql/phase1");
      }
    }
  ]).controller('ProblemController', [
    '$scope', 'playerAuth', 'problemServer', function($scope, playerAuth, server) {
      if (!playerAuth.assertLoggedIn()) {
        return;
      }
      return server.joinGame().then(function(data) {
        $scope.info = data.data;
        $scope.ProblemStage = "Stage 1";
        $scope.ProblemName = server.problem;
        $scope.stageEndTime = data.data.gameStatus.stageEnd;
        return server.getFunctions();
      }).then(function(data) {
        return $scope.functions = data.data;
      })["catch"](function(error) {
        return $scope.error = error;
      });
    }
  ]).directive('countdownTimer', [
    'dateFilter', '$interval', function(dateFilter, $interval) {
      var format;
      format = "m:ss 'Remaining'";
      return function(scope, element, attrs) {
        var stageEndTime, timer, updateTime;
        stageEndTime = 0;
        updateTime = function() {
          return element.text(dateFilter(stageEndTime - Date.now(), format));
        };
        scope.$watch(attrs.countdownTimer, function(value) {
          stageEndTime = value;
          return updateTime();
        });
        timer = $interval(updateTime, 1000);
        return element.bind('$destroy', function() {
          return $interval.cancel(timer);
        });
      };
    }
  ]).service('playerAuth', PlayerAuth).service('problemServer', ProblemServer);

}).call(this);

//# sourceMappingURL=app.map
